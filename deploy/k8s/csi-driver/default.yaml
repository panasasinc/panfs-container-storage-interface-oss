---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# PodDisruptionBudget for the CSI PanFS Controller Server
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: csi-panfs-controller-pdb
  namespace: csi-panfs
  labels:
    app: csi-panfs-controller
    product: com.vdura.csi.panfs
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: csi-panfs-controller
---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# ServiceAccount for the controller server
apiVersion: v1
kind: ServiceAccount
metadata:
  name: csi-panfs-controller
  namespace: csi-panfs
  labels:
    app: csi-panfs-controller
    product: com.vdura.csi.panfs
---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# ServiceAccount for the node driver plugin
apiVersion: v1
kind: ServiceAccount
metadata:
  name: csi-panfs-node
  namespace: csi-panfs
  labels:
    app: csi-panfs-node
    product: com.vdura.csi.panfs
---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# ClusterRole for the controller provisioner sidecar
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: csi-panfs-controller-provisioner
  labels:
    app: csi-panfs-controller
    sidecar: provisioner
    product: com.vdura.csi.panfs
rules:
  # Allow managing PersistentVolumes for provisioning and deletion
  - apiGroups: [""]
    resources: ["persistentvolumes"]
    verbs: ["get", "list", "watch", "create", "delete"]

  # Allow managing PersistentVolumeClaims for binding and updating
  - apiGroups: [""]
    resources: ["persistentvolumeclaims"]
    verbs: ["get", "list", "watch", "create", "delete", "update", "patch"]

  # Allow reading StorageClasses for provisioning decisions
  - apiGroups: ["storage.k8s.io"]
    resources: ["storageclasses"]
    verbs: ["get", "list", "watch"]

  # Allow emitting and updating Events for resource operations
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["list", "watch", "create", "update", "patch"]

  # Allow reading CSINodes for topology and node info
  - apiGroups: ["storage.k8s.io"]
    resources: ["csinodes"]
    verbs: ["get", "list", "watch"]

  # Allow reading Nodes for topology-aware provisioning
  - apiGroups: [""]
    resources: ["nodes"]
    verbs: ["get", "list", "watch"]

  # Allow reading VolumeAttachments for attach/detach operations
  - apiGroups: ["storage.k8s.io"]
    resources: ["volumeattachments"]
    verbs: ["get", "list", "watch"]
---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# ClusterRole for the attacher sidecar
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: csi-panfs-controller-attacher
  labels:
    app: csi-panfs-controller
    sidecar: attacher
    product: com.vdura.csi.panfs
rules:
  # Allow patching PersistentVolumes for attach/detach operations
  - apiGroups: [""]
    resources: ["persistentvolumes"]
    verbs: ["get", "list", "watch", "patch"]

  # Allow reading CSI node information
  - apiGroups: ["storage.k8s.io"]
    resources: ["csinodes"]
    verbs: ["get", "list", "watch"]

  # Allow managing VolumeAttachments for attach/detach
  - apiGroups: ["storage.k8s.io"]
    resources: ["volumeattachments"]
    verbs: ["get", "list", "watch", "patch"]

  # Allow updating status of VolumeAttachments
  - apiGroups: ["storage.k8s.io"]
    resources: ["volumeattachments/status"]
    verbs: ["patch"]
---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# ClusterRole for the resizer sidecar
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: csi-panfs-controller-resizer
  labels:
    app: csi-panfs-controller
    sidecar: resizer
    product: com.vdura.csi.panfs
rules:
  # Allow patching PersistentVolumes for resizing
  - apiGroups: [""]
    resources: ["persistentvolumes"]
    verbs: ["get", "list", "watch", "patch"]

  # Allow reading PersistentVolumeClaims for resizing
  - apiGroups: [""]
    resources: ["persistentvolumeclaims"]
    verbs: ["get", "list", "watch"]

  # Allow reading Pods for resizing operations
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list", "watch"]

  # Allow patching PersistentVolumeClaim status for resizing
  - apiGroups: [""]
    resources: ["persistentvolumeclaims/status"]
    verbs: ["patch"]

  # Allow managing Events related to resizing
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["list", "watch", "create", "update", "patch"]
---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# ClusterRole for the node plugin
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: csi-panfs-node
  labels:
    app: csi-panfs-node
    product: com.vdura.csi.panfs
rules:
  # Allow emitting and updating events
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["get", "list", "watch", "create", "update", "patch"]

  # Allow reading and updating node objects (for NodeID annotation, topology, etc.)
  - apiGroups: [""]
    resources: ["nodes"]
    verbs: ["get", "list", "watch", "update", "patch"]
---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# Bind the provisioner ClusterRole to the controller ServiceAccount
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: csi-panfs-controller-provisioner-rolebinding
  labels:
    app: csi-panfs-controller
    sidecar: provisioner
    product: com.vdura.csi.panfs
subjects:
  - kind: ServiceAccount
    name: csi-panfs-controller
    namespace: csi-panfs
roleRef:
  kind: ClusterRole
  name: csi-panfs-controller-provisioner
  apiGroup: rbac.authorization.k8s.io
---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# Bind the attacher ClusterRole to the controller ServiceAccount
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: csi-panfs-controller-attacher-rolebinding
  labels:
    app: csi-panfs-controller
    sidecar: attacher
    product: com.vdura.csi.panfs
subjects:
  - kind: ServiceAccount
    name: csi-panfs-controller
    namespace: csi-panfs
roleRef:
  kind: ClusterRole
  name: csi-panfs-controller-attacher
  apiGroup: rbac.authorization.k8s.io
---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# Bind the resizer ClusterRole to the controller ServiceAccount
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: csi-panfs-controller-resizer-rolebinding
  labels:
    app: csi-panfs-controller
    sidecar: resizer
    product: com.vdura.csi.panfs
subjects:
  - kind: ServiceAccount
    name: csi-panfs-controller
    namespace: csi-panfs
roleRef:
  kind: ClusterRole
  name: csi-panfs-controller-resizer
  apiGroup: rbac.authorization.k8s.io
---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# Node Server ClusterRoleBinding
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: csi-panfs-node-rolebinding
  labels:
    app: csi-panfs-node
    product: com.vdura.csi.panfs
subjects:
  - kind: ServiceAccount
    name: csi-panfs-node
    namespace: csi-panfs
roleRef:
  kind: ClusterRole
  name: csi-panfs-node
  apiGroup: rbac.authorization.k8s.io
---
# Namespace Role for reading secrets
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: csi-panfs-controller-secret-reader
  namespace: csi-panfs
  labels:
    app: csi-panfs-controller
    sidecar: secret-provisioner
    product: com.vdura.csi.panfs
rules:
  # Allow reading secrets for accessing PanFS realm credentials
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list"]
---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# Namespace Role for leader election and storage capacity tracking
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: csi-panfs-controller-provisioner
  namespace: csi-panfs
  labels:
    app: csi-panfs-controller
    sidecar: provisioner
    product: com.vdura.csi.panfs
rules:
  # Allow leader election via leases
  - apiGroups: ["coordination.k8s.io"]
    resources: ["leases"]
    verbs: ["get", "watch", "list", "delete", "update", "create"]

  # Allow managing CSIStorageCapacity objects for storage capacity tracking
  - apiGroups: ["storage.k8s.io"]
    resources: ["csistoragecapacities"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

  # Allow reading pods for topology-aware provisioning
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get"]

  # Allow reading replicasets for topology-aware provisioning
  - apiGroups: ["apps"]
    resources: ["replicasets"]
    verbs: ["get"]
---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# Namespace Role for attacher leader election
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: csi-panfs-controller-attacher
  namespace: csi-panfs
  labels:
    app: csi-panfs-controller
    sidecar: attacher
    product: com.vdura.csi.panfs
rules:
  # Allow leader election via leases for attacher sidecar
  - apiGroups: ["coordination.k8s.io"]
    resources: ["leases"]
    verbs: ["get", "watch", "list", "delete", "update", "create"]
---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# Bind the secret reader Role to the controller ServiceAccount
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: csi-panfs-controller-secret-reader-rolebinding
  namespace: csi-panfs
  labels:
    app: csi-panfs-controller
    sidecar: secret-provisioner
    product: com.vdura.csi.panfs
subjects:
  - kind: ServiceAccount
    name: csi-panfs-controller
    namespace: csi-panfs
roleRef:
  kind: Role
  name: csi-panfs-controller-secret-reader
  apiGroup: rbac.authorization.k8s.io
---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# Bind the secret reader Role to the controller ServiceAccount
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: csi-panfs-controller-secret-reader-rolebinding
  namespace: csi-panfs
  labels:
    app: csi-panfs-controller
    sidecar: secret-provisioner
    product: com.vdura.csi.panfs
subjects:
  - kind: ServiceAccount
    name: csi-panfs-controller
    namespace: csi-panfs
roleRef:
  kind: Role
  name: csi-panfs-controller-secret-reader
  apiGroup: rbac.authorization.k8s.io
---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# Bind the namespace Role to the controller ServiceAccount
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: csi-panfs-controller-provisioner-rolebinding
  namespace: csi-panfs
  labels:
    app: csi-panfs-controller
    sidecar: provisioner
    product: com.vdura.csi.panfs
subjects:
  - kind: ServiceAccount
    name: csi-panfs-controller
    namespace: csi-panfs
roleRef:
  kind: Role
  name: csi-panfs-controller-provisioner
  apiGroup: rbac.authorization.k8s.io
---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# Bind the attacher Role to the controller ServiceAccount
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: csi-panfs-controller-attacher-rolebinding
  namespace: csi-panfs
  labels:
    app: csi-panfs-controller
    sidecar: attacher
    product: com.vdura.csi.panfs
subjects:
  - kind: ServiceAccount
    name: csi-panfs-controller
    namespace: csi-panfs
roleRef:
  kind: Role
  name: csi-panfs-controller-attacher
  apiGroup: rbac.authorization.k8s.io
---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# DaemonSet for the CSI PanFS node plugin
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: csi-panfs-node
  namespace: csi-panfs
  labels:
    app: csi-panfs-node
    product: com.vdura.csi.panfs
spec: # csi-panfs-node
  selector:
    matchLabels:
      app: csi-panfs-node

  # Update strategy for the DaemonSet pods
  updateStrategy:
    rollingUpdate:
      maxUnavailable: 100%
    type: RollingUpdate

  template:
    metadata:
      labels:
        app: csi-panfs-node
        product: com.vdura.csi.panfs

    spec:
      # Pod priority class
      priorityClassName: system-cluster-critical

      # Host networking for csi driver node pods, must be set to 'true'
      hostNetwork: true

      # ServiceAccount for node plugin
      serviceAccount: csi-panfs-node

      # Uncomment the line below and set the secret name to enable pulling images from a private registry.
      imagePullSecrets:
        # - name: <IMAGE_PULL_SECRET_NAME>

      # SELinux security context
      securityContext:
        seLinuxOptions:
          level: s0
          role: system_r
          type: container_t
          user: system_u

      # Tolerations for scheduling the DaemonSet pods
      # Should match the tolerations of the PanFS consumer workloads
      # Double-check that the tolerations are correct:
      # kubectl describe node <NODE_NAME> | grep -A10 Taints
      tolerations:
        - operator: Exists

      # Ensure the DaemonSet pods are scheduled only on nodes with the PanFS kernel module loaded
      # This label is applied by the KMM operator when the PanFS module is successfully loaded
      nodeSelector:
        # Naming convention: kmm.node.kubernetes.io/<csi-driver-namespace>.<module-name>.ready
        kmm.node.kubernetes.io/csi-panfs.panfs.ready: ""

      initContainers:
        # Init container to enable PanFS mount helper
        - name: get-dfc-bin
          image: <PANFS_DFC_IMAGE> # Change to relevant DFC/KMM image
          imagePullPolicy: Always
          command: ["cp", "/usr/sbin/mount.panfs", "/var/lib/panfs/"]
          volumeMounts:
            - name: dfc-bin
              mountPath: /var/lib/panfs

      containers:
        # Main PanFS CSI node plugin container
        - name: csi-panfs-plugin
          image: ghcr.io/panasasinc/panfs-container-storage-interface-oss/panfs-csi-driver:1.2.2
          imagePullPolicy: Always
          args:
            - "--endpoint=$(CSI_ENDPOINT)"
            - "--v=5"
          env:
            - name: CSI_ENDPOINT
              value: /csi/csi.sock

          # Resource requests and limits for the driver registrar sidecar
          # Limits should be set to prevent excessive resource consumption
          # Requests should be set to ensure the container gets scheduled
          resources:
            limits:
              cpu: 300m
              memory: 600Mi
            requests:
              cpu: 100m
              memory: 200Mi

          livenessProbe:
            exec:
              command: ["sh", "-c", "test -S $(CSI_ENDPOINT)"]
            initialDelaySeconds: 10
            periodSeconds: 20
            timeoutSeconds: 5
            successThreshold: 1
            failureThreshold: 3

          # Must run in privileged mode
          securityContext:
            privileged: true
            # SELinux security context
            seLinuxOptions:
              level: s0
              role: system_r
              type: container_t
              user: system_u

          volumeMounts:
            - name: dfc-bin
              mountPath: /usr/sbin/mount.panfs
              subPath: mount.panfs

            - name: socket-dir
              mountPath: /csi

            - name: pods-mount-dir
              mountPath: /var/lib/kubelet
              mountPropagation: Bidirectional

            - name: selinux
              mountPath: /sys/fs/selinux
              mountPropagation: None

            - name: selinux-config
              mountPath: /etc/selinux
              readOnly: true

        # CSI node-driver-registrar sidecar
        - name: csi-driver-registrar
          image: k8s.gcr.io/sig-storage/csi-node-driver-registrar:v2.5.0
          imagePullPolicy: IfNotPresent
          args:
            - "--v=5"
            - "--csi-address=$(ADDRESS)"
            - "--kubelet-registration-path=$(DRIVER_REG_SOCK_PATH)"
            - "--timeout=60s"
          env:
            - name: ADDRESS
              value: /csi/csi.sock
            - name: DRIVER_REG_SOCK_PATH
              value: /var/lib/kubelet/plugins/com.vdura.csi.panfs/csi.sock

          # Resource requests and limits for the driver registrar sidecar
          # Limits should be set to prevent excessive resource consumption
          # Requests should be set to ensure the container gets scheduled
          resources:
            limits:
              cpu: 100m
              memory: 100Mi
            requests:
              cpu: 100m
              memory: 100Mi

          livenessProbe:
            exec:
              command:
                - /csi-node-driver-registrar
                - --kubelet-registration-path=$(DRIVER_REG_SOCK_PATH)
                - --mode=kubelet-registration-probe
            initialDelaySeconds: 30
            timeoutSeconds: 15

          volumeMounts:
            - name: socket-dir
              mountPath: /csi

            - name: registration-dir
              mountPath: /registration

      volumes:
        # For DFC binary
        - name: dfc-bin
          emptyDir: {}

        # For kubelet plugin registration
        - name: registration-dir
          hostPath:
            path: /var/lib/kubelet/plugins_registry
            type: DirectoryOrCreate

        # For CSI socket
        - name: socket-dir
          hostPath:
            path: /var/lib/kubelet/plugins/com.vdura.csi.panfs
            type: DirectoryOrCreate

        # For mounting volumes
        - name: pods-mount-dir
          hostPath:
            path: /var/lib/kubelet
            type: Directory

        # SELinux context support
        - name: selinux
          hostPath:
            path: /sys/fs/selinux
            type: Directory

        # SELinux configuration
        - name: selinux-config
          hostPath:
            path: /etc/selinux
            type: Directory
---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# Deployment for the CSI PanFS controller server
apiVersion: apps/v1
kind: Deployment
metadata:
  name: csi-panfs-controller
  namespace: csi-panfs
  labels:
    app: csi-panfs-controller
    product: com.vdura.csi.panfs

spec: # csi-panfs-controller

  # Number of controller replicas
  replicas: 3

  # Update strategy for the controller deployment
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1

  selector:
    matchLabels:
      app: csi-panfs-controller

  template:
    metadata:
      labels:
        app: csi-panfs-controller
        product: com.vdura.csi.panfs
    spec:

      # Affinity settings for the controller pods
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - csi-panfs-controller
              topologyKey: kubernetes.io/hostname
            weight: 100

      # Priority class for the controller pods
      priorityClassName: system-cluster-critical

      # ServiceAccount for the controller pods
      serviceAccount: csi-panfs-controller

      # Uncomment the line below and set the secret name to enable pulling images from a private registry.
      imagePullSecrets:
        # - name: <IMAGE_PULL_SECRET_NAME>

      containers:
        # Main PanFS CSI plugin container
        - name: csi-panfs-plugin
          image: ghcr.io/panasasinc/panfs-container-storage-interface-oss/panfs-csi-driver:1.2.2
          imagePullPolicy: Always
          args:
            - "--endpoint=$(CSI_ENDPOINT)"
            - "--v=5"
          env:
            - name: CSI_ENDPOINT
              value: /var/lib/csi/sockets/pluginproxy/csi.sock

          # Resource requests and limits for the driver main container
          # Adjust as necessary based on your cluster capacity and requirements
          # Limits should be set to prevent excessive resource consumption
          # Requests should be set to ensure the container gets scheduled
          resources:
            limits:
              cpu: 300m
              memory: 600Mi
            requests:
              cpu: 100m
              memory: 200Mi

          volumeMounts:
            - name: socket-dir
              mountPath: /var/lib/csi/sockets/pluginproxy

          livenessProbe:
            exec:
              command: ["sh", "-c", "test -S $(CSI_ENDPOINT)"]
            initialDelaySeconds: 10
            periodSeconds: 20
            timeoutSeconds: 5
            successThreshold: 1
            failureThreshold: 5

        # CSI sidecar container for provisioning
        - name: csi-provisioner
          image: k8s.gcr.io/sig-storage/csi-provisioner:v5.3.0
          imagePullPolicy: IfNotPresent
          args:
            - "--v=5"
            - "--csi-address=$(ADDRESS)"
            - "--http-endpoint=:8080"
            - "--timeout=60s"
            - "--worker-threads=5"
            - "--retry-interval-start=5s"
            - "--leader-election"
          env:
            - name: ADDRESS
              value: /var/lib/csi/sockets/pluginproxy/csi.sock
          ports:
            - containerPort: 8080
              name: http-endpoint
              protocol: TCP

          # Resource requests and limits for the driver provisioner sidecar
          # Adjust as necessary based on your cluster capacity and requirements
          # Limits should be set to prevent excessive resource consumption
          # Requests should be set to ensure the container gets scheduled
          resources:
            limits:
              cpu: 300m
              memory: 300Mi
            requests:
              cpu: 100m
              memory: 100Mi

          livenessProbe:
            failureThreshold: 5
            httpGet:
              path: /healthz/leader-election
              port: http-endpoint
            initialDelaySeconds: 10
            timeoutSeconds: 10
            periodSeconds: 20

          volumeMounts:
            - name: socket-dir
              mountPath: /var/lib/csi/sockets/pluginproxy

        # CSI sidecar container for attach/detach operations
        - name: csi-attacher
          image: k8s.gcr.io/sig-storage/csi-attacher:v4.9.0
          imagePullPolicy: IfNotPresent
          args:
            - "--v=5"
            - "--csi-address=$(ADDRESS)"
            - "--http-endpoint=:8081"
            - "--timeout=60s"
            - "--leader-election"
          env:
            - name: MY_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: ADDRESS
              value: /var/lib/csi/sockets/pluginproxy/csi.sock
          ports:
            - containerPort: 8081
              name: http-endpoint
              protocol: TCP

          # Resource requests and limits for the driver attacher sidecar
          # Adjust as necessary based on your cluster capacity and requirements
          # Limits should be set to prevent excessive resource consumption
          # Requests should be set to ensure the container gets scheduled
          resources:
            limits:
              cpu: 200m
              memory: 200Mi
            requests:
              cpu: 100m
              memory: 100Mi

          livenessProbe:
            failureThreshold: 5
            httpGet:
              path: /healthz/leader-election
              port: http-endpoint
            initialDelaySeconds: 10
            timeoutSeconds: 10
            periodSeconds: 20

          volumeMounts:
            - name: socket-dir
              mountPath: /var/lib/csi/sockets/pluginproxy

        # CSI sidecar container for volume resizing
        - name: csi-resizer
          image: gcr.io/k8s-staging-sig-storage/csi-resizer:v1.13.2
          imagePullPolicy: IfNotPresent
          args:
            - "--v=5"
            - "--csi-address=$(ADDRESS)"
            - "--http-endpoint=:8082"
            - "--timeout=60s"
            - "--leader-election"
          env:
            - name: ADDRESS
              value: /var/lib/csi/sockets/pluginproxy/csi.sock
          ports:
            - containerPort: 8082
              name: http-endpoint
              protocol: TCP

          # Resource requests and limits for the driver resizer sidecar
          # Adjust as necessary based on your cluster capacity and requirements
          # Limits should be set to prevent excessive resource consumption
          # Requests should be set to ensure the container gets scheduled
          resources:
            limits:
              cpu: 200m
              memory: 200Mi
            requests:
              cpu: 100m
              memory: 100Mi

          livenessProbe:
            failureThreshold: 5
            httpGet:
              path: /healthz/leader-election
              port: http-endpoint
            initialDelaySeconds: 10
            timeoutSeconds: 10
            periodSeconds: 20

          volumeMounts:
            - name: socket-dir
              mountPath: /var/lib/csi/sockets/pluginproxy

      volumes:
        # CSI socket shared between containers
        - name: socket-dir
          emptyDir: {}
---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# CSIDriver object for the PanFS CSI driver
apiVersion: storage.k8s.io/v1
kind: CSIDriver
metadata:
  name: com.vdura.csi.panfs
  annotations:
    csi-driver-namespace: csi-panfs
    csi-driver-controller-sa: csi-panfs-controller
  labels:
    product: com.vdura.csi.panfs
spec:
  attachRequired: false
  podInfoOnMount: false
  fsGroupPolicy: File
  requiresRepublish: false
  seLinuxMount: true
  volumeLifecycleModes:
    - Persistent
---
# SPDX-License-Identifier: Apache-2.0
# Copyright 2025 VDURA Inc.

# Kernel Module Manager (KMM) Module for PanFS
apiVersion: kmm.sigs.x-k8s.io/v1beta1
kind: Module
metadata:
  name: panfs
  namespace: csi-panfs
  labels:
    app: panfs-kmm-module
    product: com.vdura.csi.panfs
spec:

  # If your cluster does not inherit image pull credentials from the default ServiceAccount,
  # uncomment the line below and set the secret name to enable pulling images from a private registry.
  imageRepoSecret:
    # name: <IMAGE_PULL_SECRET_NAME>

  # Node selector for scheduling the KMM Module pods (to load the PanFS kernel module)
  # Should match the nodes where the PanFS consumer workloads supposed to run
  # Ensure that the nodes have the appropriate labels
  # kubectl get nodes --show-labels
  selector:
    node-role.kubernetes.io/worker: ""

  moduleLoader:
    container:
      modprobe:
        moduleName: panfs
      imagePullPolicy: Always

      # PanFS DFC/KMM image containing the PanFS kernel module
      kernelMappings:
        - literal: "<KERNEL_VERSION>"         # Replace with your Worker node kernel version
          containerImage: "<PANFS_DFC_IMAGE>" # Change to Kernel-related corresponding DFC/KMM image
